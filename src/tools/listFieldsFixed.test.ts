import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';

import { Server } from '../server.js';
import { getGraphqlQuery } from './listFields.js';
import { getListFieldsFixedTool } from './listFieldsFixed.js';

const mockMetadataResponses = vi.hoisted(() => ({
  success: {
    data: {
      publishedDatasources: [
        {
          name: 'Fixed Test Datasource',
          description: 'Fixed Test Description',
          owner: {
            name: 'Test Owner',
          },
          fields: [
            {
              name: 'FixedField1',
              isHidden: false,
              description: 'Fixed Field 1 Desc',
              descriptionInherited: [],
              fullyQualifiedName: '[fixedfield1]',
              __typename: 'ColumnField',
              dataCategory: 'NOMINAL',
              role: 'DIMENSION',
              dataType: 'STRING',
              defaultFormat: null,
              semanticRole: null,
              aggregation: null,
              aggregationParam: null,
            },
            {
              name: 'FixedField2',
              isHidden: false,
              description: 'Fixed Field 2 Desc',
              descriptionInherited: [
                {
                  attribute: 'description',
                  value: 'Fixed inherited description',
                },
              ],
              fullyQualifiedName: '[fixedfield2]',
              __typename: 'CalculatedField',
              dataCategory: 'QUANTITATIVE',
              role: 'MEASURE',
              dataType: 'INTEGER',
              defaultFormat: null,
              semanticRole: null,
              aggregation: 'Sum',
              aggregationParam: null,
              formula: 'SUM([fixedfield1])',
              isAutoGenerated: false,
              hasUserReference: true,
            },
          ],
        },
      ],
    },
  },
  empty: {
    data: {
      publishedDatasources: [],
    },
  },
}));

const mocks = vi.hoisted(() => ({
  mockGraphql: vi.fn(),
  mockGetConfig: vi.fn(),
}));

vi.mock('../config.js', () => ({
  getConfig: mocks.mockGetConfig,
}));

vi.mock('../restApiInstance.js', () => ({
  useRestApi: vi.fn().mockImplementation(async ({ callback }) =>
    callback({
      metadataMethods: {
        graphql: mocks.mockGraphql,
      },
    }),
  ),
}));

describe('listFieldsFixedTool', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should create a tool instance with correct properties', () => {
    mocks.mockGetConfig.mockReturnValue({ fixedDatasourceLuid: 'fixed-test-luid' });

    const listFieldsFixedTool = getListFieldsFixedTool(new Server());
    expect(listFieldsFixedTool.name).toBe('list-fields-fixed');
    expect(listFieldsFixedTool.paramsSchema).toEqual({});
  });

  it('should return error when FIXED_DATASOURCE_LUID is not configured', async () => {
    mocks.mockGetConfig.mockReturnValue({ fixedDatasourceLuid: null });

    const result = await getToolResult();

    expect(result.isError).toBe(true);
    expect(result.content[0].text).toContain(
      'FIXED_DATASOURCE_LUID environment variable is not configured',
    );
  });

  it('should return error when FIXED_DATASOURCE_LUID is empty string', async () => {
    mocks.mockGetConfig.mockReturnValue({ fixedDatasourceLuid: null });

    const result = await getToolResult();

    expect(result.isError).toBe(true);
    expect(result.content[0].text).toContain(
      'FIXED_DATASOURCE_LUID environment variable is not configured',
    );
  });

  it('should successfully fetch and return field metadata using fixed datasource LUID', async () => {
    mocks.mockGetConfig.mockReturnValue({ fixedDatasourceLuid: 'fixed-test-luid' });
    mocks.mockGraphql.mockResolvedValue(mockMetadataResponses.success);

    const result = await getToolResult();

    expect(result.isError).toBe(false);
    expect(JSON.parse(result.content[0].text as string)).toEqual(mockMetadataResponses.success);
    expect(mocks.mockGraphql).toHaveBeenCalledWith(getGraphqlQuery('fixed-test-luid'));
  });

  it('should successfully fetch and return empty list when no published datasources are found', async () => {
    mocks.mockGetConfig.mockReturnValue({ fixedDatasourceLuid: 'fixed-test-luid' });
    mocks.mockGraphql.mockResolvedValue(mockMetadataResponses.empty);

    const result = await getToolResult();

    expect(result.isError).toBe(false);
    expect(JSON.parse(result.content[0].text as string)).toEqual(mockMetadataResponses.empty);
    expect(mocks.mockGraphql).toHaveBeenCalledWith(getGraphqlQuery('fixed-test-luid'));
  });

  it('should handle API errors gracefully', async () => {
    mocks.mockGetConfig.mockReturnValue({ fixedDatasourceLuid: 'fixed-test-luid' });
    const errorMessage = 'Fixed API Error';
    mocks.mockGraphql.mockRejectedValue(new Error(errorMessage));

    const result = await getToolResult();
    expect(result.isError).toBe(true);
    expect(result.content[0].text).toBe('requestId: test-request-id, error: Fixed API Error');
  });
});

async function getToolResult(): Promise<CallToolResult> {
  const listFieldsFixedTool = getListFieldsFixedTool(new Server());
  return await listFieldsFixedTool.callback(
    {}, // No parameters for fixed tool
    {
      signal: new AbortController().signal,
      requestId: 'test-request-id',
      sendNotification: vi.fn(),
      sendRequest: vi.fn(),
    },
  );
}
